/* Notorious Six Vibrance
    v0.0.1
    ------------------

    Vibrance emulates what happens to color in the bottom end of
    a per-channel contrast increase: Secondary hues are bent towards primary hues.

    Image "richness" is increased without slamming into the gamut boundary as with a 
    traditional saturation adjustment. 
    
    However hue shifts can occur. Sometimes disireable, sometimes not.

    Written by Jed Smith
    github.com/jedypod/open-display-transform
*/


DEFINE_UI_PARAMS(vi, global, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vy, yellow, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vr, red, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vm, magenta, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vb, blue, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vc, cyan, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(vg, green, DCTLUI_SLIDER_FLOAT, 0, -1, 1, 0)
DEFINE_UI_PARAMS(ze, zoned, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(zp, zone range, DCTLUI_SLIDER_FLOAT, 0, -4, 4, 0)
DEFINE_UI_PARAMS(zr, zone, DCTLUI_COMBO_BOX, 0, {low, high}, {low, high})


__DEVICE__ float extract(float e0, float e1, float x) {
  // Extract a range from e0 to e1 from f, clamping values above or below.
  return _clampf((x - e0) / (e1 - e0), 0.0f, 1.0f);
}

__DEVICE__ float extract_window(float e0, float e1, float e2, float e3, float x) {
  // Linear window function to extract a range from float x
  // https://www.desmos.com/calculator/uzsk5ta5v7
  return x < e1 ? extract(e0, e1, x) : extract(e3, e2, x);
}

__DEVICE__ float extract_hue_angle(float h, float o, float w) {
  // Given hue, offset, width, extract hue angle
  float hc = extract_window(2.0f - w, 2.0f, 2.0f, 2.0f + w, _fmod(h + o, 6.0f));
  return hc;
}

__DEVICE__ float hue(float3 rgb) {
  // Calculate and return hue in degrees between 0 and 6
  float mx = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));
  float mn = _fminf(rgb.x, _fminf(rgb.y, rgb.z));
  float ch = mx - mn;
  float h;
  if (ch == 0.0f) h = 0.0f;
  else if (mx == rgb.x) h = _fmod((rgb.y - rgb.z) / ch + 6.0f, 6.0f);
  else if (mx == rgb.y) h = (rgb.z - rgb.x) / ch + 2.0f;
  else if (mx == rgb.z) h = (rgb.x - rgb.y) / ch + 4.0f;
  return h;
}

__DEVICE__ float3 powf3(float3 a, float b) { 
  return make_float3(_powf(a.x, b), _powf(a.y, b), _powf(a.z, b));
}


__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) 
{
  // Parameter setup
  float3 pp = make_float3(
    (vr > 0.0f ? (vr + 1.0f) : (vr / 2.0f + 1.0f))*(vi+1.0f),
    (vg > 0.0f ? (vg + 1.0f) : (vg / 2.0f + 1.0f))*(vi+1.0f),
    (vb > 0.0f ? (vb + 1.0f) : (vb / 2.0f + 1.0f))*(vi+1.0f));
  float3 ps = make_float3(
    (vc > 0.0f ? (vc + 1.0f) : (vc / 2.0f + 1.0f))*(vi+1.0f),
    (vm > 0.0f ? (vm + 1.0f) : (vm / 2.0f + 1.0f))*(vi+1.0f),
    (vy > 0.0f ? (vy + 1.0f) : (vy / 2.0f + 1.0f))*(vi+1.0f));

  pp = powf3(pp, 2);
  ps = powf3(ps, 0.5f);


  float3 rgb = make_float3(p_R, p_G, p_B);
  float3 in = rgb;

  // max(r,g,b) norm
  float n = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));
  
  float3 r; // RGB Ratios
  if (n == 0.0f) r = make_float3(0.0f, 0.0f, 0.0f);
  else r = rgb / n;
  // r = clamp_min_f3(r, -1.0f);

  float h = hue(r);

  // hue extraction for primaries (RGB)
  float3 hp = make_float3(
    extract_hue_angle(h, 2.0f, 1.0f),
    extract_hue_angle(h, 6.0f, 1.0f),
    extract_hue_angle(h, 4.0f, 1.0f));

  // hue extraction for secondaries (CMY)
  float3 hs = make_float3(
    extract_hue_angle(h, 5.0f, 1.0f),
    extract_hue_angle(h, 3.0f, 1.0f),
    extract_hue_angle(h, 1.0f, 1.0f));

  r.x = r.x < 0.0f ? r.x : _powf(r.x, pp.x) * hp.x + _powf(r.x, pp.y) * hp.y + _powf(r.x, pp.z) * hp.z + r.x * (1.0f - (hp.x + hp.y + hp.z));
  r.y = r.y < 0.0f ? r.y : _powf(r.y, pp.x) * hp.x + _powf(r.y, pp.y) * hp.y + _powf(r.y, pp.z) * hp.z + r.y * (1.0f - (hp.x + hp.y + hp.z));
  r.z = r.z < 0.0f ? r.z : _powf(r.z, pp.x) * hp.x + _powf(r.z, pp.y) * hp.y + _powf(r.z, pp.z) * hp.z + r.z * (1.0f - (hp.x + hp.y + hp.z));

  r.x = r.x < 0.0f ? r.x : _powf(r.x, ps.x) * hs.x + _powf(r.x, ps.y) * hs.y + _powf(r.x, ps.z) * hs.z + r.x * (1.0f - (hs.x + hs.y + hs.z));
  r.y = r.y < 0.0f ? r.y : _powf(r.y, ps.x) * hs.x + _powf(r.y, ps.y) * hs.y + _powf(r.y, ps.z) * hs.z + r.y * (1.0f - (hs.x + hs.y + hs.z));
  r.z = r.z < 0.0f ? r.z : _powf(r.z, ps.x) * hs.x + _powf(r.z, ps.y) * hs.y + _powf(r.z, ps.z) * hs.z + r.z * (1.0f - (hs.x + hs.y + hs.z));

  rgb = r * n;

  // Zone extract
  if (ze == 1) {
    const float fl = 0.004f;
    float zpow = _powf(2.0f, -zp + 1.0f);
    float toe = (n * n / (n + fl));
    float f = _powf((toe / (toe + 1.0f)) / n, zpow);
    if (zr == high) f = 1.0f - _powf((n / (n + 1.0f)) / n, zpow);
    rgb = in * (1.0f - f) + rgb * f;
  }

  return rgb;
}